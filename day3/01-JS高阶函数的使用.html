<!-- //普通的for循环
totalPrice() {
    // let totalPrice = 0;
    // for (let i = 0; i < this.bookInfor.length; i++) {
    //     totalPrice += this.bookInfor[i].price * this.bookInfor[i].buyNumber;

    // }
    //2.for (let i in this.books)
//     let totalPrice = 0;
// for (let i in this.bookInfor){
//     totalPrice += this.bookInfor[i].price * this.bookInfor[i].buyNumber;
// }

// // 3.for (let books of this.bookInfor)(最方便的一种提取遍历数组中每个元素的方式)
// let totalPrice = 0;
//         for (let books of this.bookInfor){
//     totalPrice += books.price * books.buyNumber;
// }


// 4.reduce（一种高阶的算法）




// 编程范式：1.命令式编程
//          2.申明式编程
//          3.面向对象编程（第一公民：对象）
//          4.函数式编程（第一公民：函数）


//传统编程方式

// //需求1：去除所有小于100的数字
// //const nums = [12, 12, 500, 6000]
// let newNums = []
// for(let n of nums){
//     if(n<100){
//         newNums.push(n)
//     }
// }

// //需求2：将所有小于100的数字进行转化：全部*2
// let new2Nems =[]
// for(let n of new2Nums){
//     new2Nums.push(n*2)
// }
// console.log(new2Nums);

// //需求3：将所有new2Nums的数字相加，的到最终的结果
// let total =0
// for(let n of new2Nums){
//     total+=n
// }
// console.log(total);


//函数式编程
// filter/map/reduce(都是高级函数)

const nums = [12, 12, 500, 6000]

//1.filter函数的使用
// filter中的一个回调函数有一个要求：必须返回一个boolean
// true/false
// true：当返回true时，函数内部会自动将这次回调的n加入到新的数组中
// false：当你返回一个false时，函数内部会过滤掉这次的n
// let newNums = nums.filter(function(n){
//     return n<100 //给n加上限制条件即可进行筛选同时输出并组成新的数组
// })

//2.map函数的使用

let newNums = nums.map(function(n){
return n*2 //map函数可以对数组中的每个元素进行一次相同的运算，然后生成新的数组
})

// 3.reduce函数
// let newNums = nums.reduce(function(preValue,n){
//     return preValue+n //reduce的作用，对数组中的所有内容进行汇总
// },0)
//preValue是每次循环后reduce函数的一个返回值
//以上面的函数为例下面将进行分布分析
//第一次循环：priValue = 0 n=12
//第二次循环：priValue = 12 n=12
//第三次循环：priValue = 24 n=500
//第四次循环：priValue = 524 n=6000


// 简单的高阶函数是应用实例
// let total=nums.filder(function(n){
//     return n<100;
// }).map(function(n){
//     return n*2;
// }).reduce(function(prValue,n){
//     return prValue+n
// },0)

// 简写
// let total=nums.filter(n=>n<100).map(n=>n*2).reduce((pre,n)=>pre+n); -->
<!-- 
不通过for遍历来实现上面的要求
return thsi .books.reduce(function(preValue,book){
    return preValue+book.price*book.count
},0) -->